"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.noSchemaDataModelDTS = noSchemaDataModelDTS;
exports.dynamicDataModelDTS = dynamicDataModelDTS;
var common_js_1 = require("./common.js");
function noSchemaDataModelDTS() {
    return "\n  ".concat((0, common_js_1.header)("Generated data model types."), "\n  import { AnyDataModel } from \"@smartbill/firestore-convex-style/server\";\n  import type { GenericId } from \"@smartbill/firestore-convex-style/values\";\n\n  /**\n   * No `schema.ts` file found!\n   *\n   * This generated code has permissive types like `Doc = any` because\n   * We doesn't know your schema. If you'd like more type safety, see\n   * .... todo(docs url) for instructions on how to add a\n   * schema file.\n   *\n   * After you change a schema, rerun codegen with `npx @smartbill/firestore-convex-style dev`.\n   */\n\n  /**\n   * The names of all of your Firestore tables.\n   */\n  export type TableNames = string;\n\n  /**\n   * The type of a document stored in Firestore.\n   */\n  export type Doc = any;\n\n  /**\n   * An identifier for a document in Firestore.\n   *\n   * Firestore documents are uniquely identified by their `Id`, which is accessible\n   * on the `_id` field. To learn more, see [Document IDs](https://firebase.google.com/docs/firestore/manage-data/add-data#document_ids).\n   *\n   * Documents can be loaded using `db.get(id)` in query and mutation functions.\n   *\n   * IDs are just strings at runtime, but this type can be used to distinguish them from other\n   * strings when type checking.\n   */\n  export type Id<TableName extends TableNames = TableNames> = GenericId<TableName>;\n\n  /**\n   * A type describing your Firestore data model.\n   *\n   * This type includes information about what tables you have, the type of\n   * documents stored in those tables, and the indexes defined on them.\n   *\n   * This type is used to parameterize methods like `queryGeneric` and\n   * `mutationGeneric` to make them type-safe.\n   */\n  export type DataModel = AnyDataModel;");
}
function dynamicDataModelDTS() {
    return "".concat((0, common_js_1.header)("Generated data model types."), "\nimport type { DataModelFromSchemaDefinition, DocumentByName, TableNamesInDataModel } from \"@smartbill/firestore-convex-style/server\";\nimport type { GenericId } from \"@smartbill/firestore-convex-style/values\";\nimport schema from \"../schema.js\";\n\n/**\n * The names of all of your Convex tables.\n */\nexport type TableNames = TableNamesInDataModel<DataModel>;\n\n/**\n * The type of a document stored in Convex.\n *\n * @typeParam TableName - A string literal type of the table name (like \"users\").\n */\nexport type Doc<TableName extends TableNames> = DocumentByName<DataModel, TableName>;\n\n/**\n * An identifier for a document in Convex.\n *\n * Convex documents are uniquely identified by their `Id`, which is accessible\n * on the `_id` field. To learn more, see [Document IDs](https://docs.convex.dev/using/document-ids).\n *\n * Documents can be loaded using `db.get(id)` in query and mutation functions.\n *\n * IDs are just strings at runtime, but this type can be used to distinguish them from other\n * strings when type checking.\n *\n * @typeParam TableName - A string literal type of the table name (like \"users\").\n */\nexport type Id<TableName extends TableNames> = GenericId<TableName>;\n\n/**\n * A type describing your Convex data model.\n *\n * This type includes information about what tables you have, the type of\n * documents stored in those tables, and the indexes defined on them.\n *\n * This type is used to parameterize methods like `queryGeneric` and\n * `mutationGeneric` to make them type-safe.\n */\nexport type DataModel = DataModelFromSchemaDefinition<typeof schema>;");
}
