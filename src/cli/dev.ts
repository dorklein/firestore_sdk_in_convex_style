#!/usr/bin/env node

import * as path from "path";
import * as fs from "fs";

interface CodegenOptions {
  schemaPath: string;
  outputDir: string;
}

async function generateTypes(options: CodegenOptions): Promise<void> {
  const { schemaPath, outputDir } = options;

  // Create _generated directory if it doesn't exist
  const generatedDir = path.join(outputDir, "_generated");
  if (!fs.existsSync(generatedDir)) {
    fs.mkdirSync(generatedDir, { recursive: true });
  }

  // Generate schema.ts (re-export the schema for code generation)
  const schemaContent = generateSchemaFile(schemaPath, outputDir);
  fs.writeFileSync(path.join(generatedDir, "schema.ts"), schemaContent);

  // Generate dataModel.ts
  const dataModelContent = generateDataModelFile(outputDir);
  fs.writeFileSync(path.join(generatedDir, "dataModel.ts"), dataModelContent);

  // Generate server.ts (contains query/mutation builders)
  const serverContent = generateServerFile(outputDir);
  fs.writeFileSync(path.join(generatedDir, "server.ts"), serverContent);

  console.log(`‚úÖ Generated types in ${generatedDir}`);
}

function generateSchemaFile(schemaPath: string, outputDir: string): string {
  // Calculate relative path from _generated to schema
  const generatedDir = path.join(outputDir, "_generated");
  const relativePath = path.relative(generatedDir, schemaPath);

  const relativeImport = relativePath.replace(/\\/g, "/").replace(/\.ts$/, ".js");

  return `/**
 * This file is auto-generated by the Firestore Convex Style SDK.
 * Do not edit this file manually.
 */

export { schema } from "${relativeImport.startsWith(".") ? relativeImport : `./${relativeImport}`}";
`;
}

function generateDataModelFile(outputDir: string): string {
  // Determine if we're in src or examples directory to set the import path correctly
  const isSrcDir = outputDir.includes("src") && !outputDir.includes("examples");
  const importPrefix = isSrcDir ? "../" : "../../src/";

  return `/**
 * This file is auto-generated by the Firestore Convex Style SDK.
 * Do not edit this file manually.
 */

import type { GenericId } from "${importPrefix}values/index.js";
import { schema } from "./schema.js";
import { DocumentByName, TableNamesInDataModel } from "${importPrefix}data_model.js";
import { DataModelFromSchemaDefinition } from "${importPrefix}schema.js";

/**
 * The names of all of your Convex tables.
 */
export type TableNames = TableNamesInDataModel<DataModel>;

/**
 * The type of a document stored in Convex.
 *
 * @typeParam TableName - A string literal type of the table name (like "users").
 */
export type Doc<TableName extends TableNames> = DocumentByName<DataModel, TableName>;

/**
 * An identifier for a document in Convex.
 *
 * Convex documents are uniquely identified by their \`Id\`, which is accessible
 * on the \`_id\` field. To learn more, see [Document IDs](https://docs.convex.dev/using/document-ids).
 *
 * Documents can be loaded using \`db.get(id)\` in query and mutation functions.
 *
 * IDs are just strings at runtime, but this type can be used to distinguish them from other
 * strings when type checking.
 *
 * @typeParam TableName - A string literal type of the table name (like "users").
 */
export type Id<TableName extends TableNames> = GenericId<TableName>;

/**
 * A type describing your Convex data model.
 *
 * This type includes information about what tables you have, the type of
 * documents stored in those tables, and the indexes defined on them.
 *
 * This type is used to parameterize methods like \`queryGeneric\` and
 * \`mutationGeneric\` to make them type-safe.
 */
export type DataModel = DataModelFromSchemaDefinition<typeof schema>;
`;
}

function generateServerFile(outputDir: string): string {
  // Determine if we're in src or examples directory to set the import path correctly
  const isSrcDir = outputDir.includes("src") && !outputDir.includes("examples");
  const importPrefix = isSrcDir ? "../" : "../../src/";

  return `/**
 * This file is auto-generated by the Firestore Convex Style SDK.
 * Do not edit this file manually.
 */

import {
  GenericQueryCtx,
  GenericMutationCtx,
  QueryBuilder as QueryBuilderType,
  MutationBuilder as MutationBuilderType,
  queryGeneric,
  mutationGeneric,
  internalQueryGeneric,
  internalMutationGeneric,
} from "${importPrefix}index.js";
import type { DataModel } from "./dataModel.js";

/**
 * Define a query in this Convex app's public API.
 *
 * This function will be allowed to read your Convex database and will be accessible from the client.
 *
 * @param func - The query function. It receives a {@link QueryCtx} as its first argument.
 * @returns The wrapped query. Include this as an \`export\` to name it and make it accessible.
 */
export const query: QueryBuilderType<DataModel, "public"> = queryGeneric();

/**
 * Define a query that is only accessible from other Convex functions (but not from the client).
 *
 * This function will be allowed to read from your Convex database. It will not be accessible from the client.
 *
 * @param func - The query function. It receives a {@link QueryCtx} as its first argument.
 * @returns The wrapped query. Include this as an \`export\` to name it and make it accessible.
 */
export const internalQuery: QueryBuilderType<DataModel, "internal"> = internalQueryGeneric();

/**
 * Define a mutation in this Convex app's public API.
 *
 * This function will be allowed to modify your Convex database and will be accessible from the client.
 *
 * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.
 * @returns The wrapped mutation. Include this as an \`export\` to name it and make it accessible.
 */
export const mutation: MutationBuilderType<DataModel, "public"> = mutationGeneric();

/**
 * Define a mutation that is only accessible from other Convex functions (but not from the client).
 *
 * This function will be allowed to modify your Convex database. It will not be accessible from the client.
 *
 * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.
 * @returns The wrapped mutation. Include this as an \`export\` to name it and make it accessible.
 */
export const internalMutation: MutationBuilderType<DataModel, "internal"> = internalMutationGeneric();

/**
 * A set of services for use within Convex query functions.
 *
 * The query context is passed as the first argument to any Convex query
 * function run on the server.
 *
 * This differs from the {@link MutationCtx} because all of the services are
 * read-only.
 */
export type QueryCtx = GenericQueryCtx<DataModel>;

/**
 * A set of services for use within Convex mutation functions.
 *
 * The mutation context is passed as the first argument to any Convex mutation
 * function run on the server.
 */
export type MutationCtx = GenericMutationCtx<DataModel>;
`;
}

async function main() {
  const args = process.argv.slice(2);
  const watchMode = args.includes("--watch") || args.includes("-w");

  // Find schema file
  const possibleSchemaPaths = [
    path.join(process.cwd(), "examples", "schema.ts"),
    path.join(process.cwd(), "src", "schema.ts"),
    path.join(process.cwd(), "schema.ts"),
    path.join(process.cwd(), "convex", "schema.ts"),
  ];

  // Allow specifying custom schema path
  const schemaArgIndex = args.indexOf("--schema");
  if (schemaArgIndex !== -1 && args[schemaArgIndex + 1]) {
    possibleSchemaPaths.unshift(path.join(process.cwd(), args[schemaArgIndex + 1]));
  }

  const schemaPath = possibleSchemaPaths.find((p) => fs.existsSync(p));

  if (!schemaPath) {
    console.error("‚ùå Could not find schema.ts file.");
    console.error("   Looked in:");
    possibleSchemaPaths.forEach((p) => console.error(`   - ${p}`));
    console.error("\n   You can specify a custom path with --schema <path>");
    process.exit(1);
  }

  console.log(`üìÑ Found schema at ${schemaPath}`);

  const outputDir = path.dirname(schemaPath);

  try {
    if (watchMode) {
      console.log(`üëÄ Watching for changes to ${schemaPath}...`);

      // Initial generation
      await generateTypes({ schemaPath, outputDir });

      // Watch for file changes
      fs.watch(schemaPath, async (eventType) => {
        if (eventType === "change") {
          console.log(`\nüîÑ Schema changed, regenerating types...`);
          try {
            await generateTypes({ schemaPath, outputDir });
          } catch (error) {
            console.error("‚ùå Error regenerating types:", error);
          }
        }
      });

      // Keep the process running
      process.stdin.resume();
    } else {
      await generateTypes({ schemaPath, outputDir });
    }
  } catch (error) {
    console.error("‚ùå Error:", error);
    process.exit(1);
  }
}

main().catch((error) => {
  console.error("‚ùå Fatal error:", error);
  process.exit(1);
});
