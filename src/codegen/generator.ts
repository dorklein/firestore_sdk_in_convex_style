import * as fs from "fs";
import * as path from "path";
import { SchemaDefinition } from "../schema.js";

export interface CodegenOptions {
  schemaPath: string;
  outputDir: string;
}

/**
 * Generate TypeScript type files from a schema definition
 */
export async function generateTypes(options: CodegenOptions): Promise<void> {
  const { schemaPath, outputDir } = options;

  // Dynamically import the schema
  const schemaModule = await import(path.resolve(schemaPath));
  const schema: SchemaDefinition<any, any> = schemaModule.schema || schemaModule.default;

  if (!schema) {
    throw new Error(`No schema export found in ${schemaPath}`);
  }

  // Create _generated directory if it doesn't exist
  const generatedDir = path.join(outputDir, "_generated");
  if (!fs.existsSync(generatedDir)) {
    fs.mkdirSync(generatedDir, { recursive: true });
  }

  // Generate schema.ts (re-export the schema for code generation)
  const schemaContent = generateSchemaFile(schemaPath);
  fs.writeFileSync(path.join(generatedDir, "schema.ts"), schemaContent);

  // Generate dataModel.ts
  const dataModelContent = generateDataModelFile();
  fs.writeFileSync(path.join(generatedDir, "dataModel.ts"), dataModelContent);

  // Generate server.ts (contains query/mutation builders)
  const serverContent = generateServerFile();
  fs.writeFileSync(path.join(generatedDir, "server.ts"), serverContent);

  console.log(`‚úÖ Generated types in ${generatedDir}`);
}

function generateSchemaFile(schemaPath: string): string {
  // Calculate relative path from _generated to schema
  const relativePath = path.relative(path.join(path.dirname(schemaPath), "_generated"), schemaPath);

  const relativeImport = relativePath.replace(/\\/g, "/").replace(/\.ts$/, ".js");

  return `/**
 * This file is auto-generated by the Firestore Convex Style SDK.
 * Do not edit this file manually.
 */

export { schema } from "${relativeImport.startsWith(".") ? relativeImport : `./${relativeImport}`}";
`;
}

function generateDataModelFile(): string {
  return `/**
 * This file is auto-generated by the Firestore Convex Style SDK.
 * Do not edit this file manually.
 */

import type { GenericId } from "../values/index.js";
import { schema } from "./schema.js";
import { DocumentByName, TableNamesInDataModel } from "../data_model.js";
import { DataModelFromSchemaDefinition } from "../schema.js";

/**
 * The names of all of your Convex tables.
 */
export type TableNames = TableNamesInDataModel<DataModel>;

/**
 * The type of a document stored in Convex.
 *
 * @typeParam TableName - A string literal type of the table name (like "users").
 */
export type Doc<TableName extends TableNames> = DocumentByName<DataModel, TableName>;

/**
 * An identifier for a document in Convex.
 *
 * Convex documents are uniquely identified by their \`Id\`, which is accessible
 * on the \`_id\` field. To learn more, see [Document IDs](https://docs.convex.dev/using/document-ids).
 *
 * Documents can be loaded using \`db.get(id)\` in query and mutation functions.
 *
 * IDs are just strings at runtime, but this type can be used to distinguish them from other
 * strings when type checking.
 *
 * @typeParam TableName - A string literal type of the table name (like "users").
 */
export type Id<TableName extends TableNames> = GenericId<TableName>;

/**
 * A type describing your Convex data model.
 *
 * This type includes information about what tables you have, the type of
 * documents stored in those tables, and the indexes defined on them.
 *
 * This type is used to parameterize methods like \`queryGeneric\` and
 * \`mutationGeneric\` to make them type-safe.
 */
export type DataModel = DataModelFromSchemaDefinition<typeof schema>;
`;
}

function generateServerFile(): string {
  return `/**
 * This file is auto-generated by the Firestore Convex Style SDK.
 * Do not edit this file manually.
 */

import {
  GenericQueryCtx,
  GenericMutationCtx,
  QueryBuilder as QueryBuilderType,
  MutationBuilder as MutationBuilderType,
  queryGeneric,
  mutationGeneric,
  internalQueryGeneric,
  internalMutationGeneric,
} from "../index.js";
import type { DataModel } from "./dataModel.js";

/**
 * Define a query in this Convex app's public API.
 *
 * This function will be allowed to read your Convex database and will be accessible from the client.
 *
 * @param func - The query function. It receives a {@link QueryCtx} as its first argument.
 * @returns The wrapped query. Include this as an \`export\` to name it and make it accessible.
 */
export const query: QueryBuilderType<DataModel, "public"> = queryGeneric;

/**
 * Define a query that is only accessible from other Convex functions (but not from the client).
 *
 * This function will be allowed to read from your Convex database. It will not be accessible from the client.
 *
 * @param func - The query function. It receives a {@link QueryCtx} as its first argument.
 * @returns The wrapped query. Include this as an \`export\` to name it and make it accessible.
 */
export const internalQuery: QueryBuilderType<DataModel, "internal"> = internalQueryGeneric;

/**
 * Define a mutation in this Convex app's public API.
 *
 * This function will be allowed to modify your Convex database and will be accessible from the client.
 *
 * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.
 * @returns The wrapped mutation. Include this as an \`export\` to name it and make it accessible.
 */
export const mutation: MutationBuilderType<DataModel, "public"> = mutationGeneric;

/**
 * Define a mutation that is only accessible from other Convex functions (but not from the client).
 *
 * This function will be allowed to modify your Convex database. It will not be accessible from the client.
 *
 * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.
 * @returns The wrapped mutation. Include this as an \`export\` to name it and make it accessible.
 */
export const internalMutation: MutationBuilderType<DataModel, "internal"> = internalMutationGeneric;

/**
 * A set of services for use within Convex query functions.
 *
 * The query context is passed as the first argument to any Convex query
 * function run on the server.
 *
 * This differs from the {@link MutationCtx} because all of the services are
 * read-only.
 */
export type QueryCtx = GenericQueryCtx<DataModel>;

/**
 * A set of services for use within Convex mutation functions.
 *
 * The mutation context is passed as the first argument to any Convex mutation
 * function run on the server.
 */
export type MutationCtx = GenericMutationCtx<DataModel>;
`;
}

/**
 * Watch for changes to schema files and regenerate types
 */
export async function watchAndGenerate(options: CodegenOptions): Promise<void> {
  console.log(`üëÄ Watching for changes to ${options.schemaPath}...`);

  // Initial generation
  await generateTypes(options);

  // Watch for file changes
  fs.watch(options.schemaPath, async (eventType) => {
    if (eventType === "change") {
      console.log(`\nüîÑ Schema changed, regenerating types...`);
      try {
        // Clear the require cache to reload the schema
        const resolvedPath = path.resolve(options.schemaPath);
        delete require.cache[resolvedPath];

        await generateTypes(options);
      } catch (error) {
        console.error("‚ùå Error regenerating types:", error);
      }
    }
  });

  // Keep the process running
  process.stdin.resume();
}
