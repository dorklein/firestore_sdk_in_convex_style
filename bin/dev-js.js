#!/usr/bin/env node

import * as path from "path";
import * as fs from "fs";
import { fileURLToPath } from "url";
import { dirname, join } from "path";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Simple codegen implementation that doesn't require tsx
async function generateTypes(options) {
  const { schemaPath, outputDir } = options;

  // Create _generated directory if it doesn't exist
  const generatedDir = path.join(outputDir, "_generated");
  if (!fs.existsSync(generatedDir)) {
    fs.mkdirSync(generatedDir, { recursive: true });
  }

  // Generate a simple dataModel.ts file
  const dataModelContent = `// Auto-generated file - do not edit manually
// Generated by @smartbill/firestore-convex-style

export interface DataModel {
  // Add your data model types here
  // This is a placeholder - implement your actual data model
}

export type TableNames = keyof DataModel;
export type DocumentNames = DataModel[TableNames];
`;

  fs.writeFileSync(path.join(generatedDir, "dataModel.ts"), dataModelContent);

  // Generate a simple server.ts file
  const serverContent = `// Auto-generated file - do not edit manually
// Generated by @smartbill/firestore-convex-style

export interface ServerFunctions {
  // Add your server functions here
  // This is a placeholder - implement your actual server functions
}

export type FunctionNames = keyof ServerFunctions;
`;

  fs.writeFileSync(path.join(generatedDir, "server.ts"), serverContent);

  console.log(`‚úÖ Generated types in ${generatedDir}`);
}

const defaultRootDirectory = path.join(process.cwd(), "examples");
async function main() {
  const args = process.argv.slice(2);
  const watchMode = args.includes("--watch") || args.includes("-w");

  // Find schema file
  const possibleSchemaPaths = [
    path.join(defaultRootDirectory, "schema.ts"),
    path.join(process.cwd(), "schema.ts"),
    path.join(process.cwd(), "src", "schema.ts"),
    path.join(process.cwd(), "convex", "schema.ts"),
  ];

  // Allow specifying custom schema path
  const schemaArgIndex = args.indexOf("--schema");
  if (schemaArgIndex !== -1 && args[schemaArgIndex + 1]) {
    possibleSchemaPaths.unshift(path.join(process.cwd(), args[schemaArgIndex + 1]));
  }

  const schemaPath = possibleSchemaPaths.find((p) => fs.existsSync(p));

  if (!schemaPath) {
    console.error("‚ùå Could not find schema.ts file.");
    console.error("   Looked in:");
    possibleSchemaPaths.forEach((p) => console.error(`   - ${p}`));
    console.error("\n   You can specify a custom path with --schema <path>");
    process.exit(1);
  }

  console.log(`üìÑ Found schema at ${schemaPath}`);

  const outputDir = path.dirname(schemaPath);

  try {
    if (watchMode) {
      console.log(`üëÄ Watching for changes to ${schemaPath}...`);

      // Initial generation
      await generateTypes({ schemaPath, outputDir });

      // Watch for file changes
      fs.watch(schemaPath, async (eventType) => {
        if (eventType === "change") {
          console.log(`\nüîÑ Schema changed, regenerating types...`);
          try {
            await generateTypes({ schemaPath, outputDir });
          } catch (error) {
            console.error("‚ùå Error regenerating types:", error);
          }
        }
      });

      // Keep the process running
      process.stdin.resume();
    } else {
      await generateTypes({ schemaPath, outputDir });
    }
  } catch (error) {
    console.error("‚ùå Error:", error);
    process.exit(1);
  }
}

main().catch((error) => {
  console.error("‚ùå Fatal error:", error);
  process.exit(1);
});
